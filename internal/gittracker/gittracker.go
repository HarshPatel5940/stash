package gittracker

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type GitRepo struct {
	Path      string   `json:"path"`
	RemoteURL string   `json:"remote_url"`
	Branch    string   `json:"branch"`
	Dirty     bool     `json:"dirty"`
	Remotes   []string `json:"remotes"`
}

type GitTracker struct {
	outputDir string
	repos     []GitRepo
	seenPaths map[string]bool
}

func NewGitTracker(outputDir string) *GitTracker {
	return &GitTracker{
		outputDir: outputDir,
		repos:     []GitRepo{},
		seenPaths: make(map[string]bool),
	}
}

func (gt *GitTracker) ScanDirectories(searchDirs []string) error {
	for _, dir := range searchDirs {
		if err := gt.scanDir(dir, 0, 5); err != nil {

			continue
		}
	}
	return nil
}

func (gt *GitTracker) scanDir(dir string, depth, maxDepth int) error {
	if depth > maxDepth {
		return nil
	}

	if strings.HasPrefix(dir, "~") {
		homeDir, _ := os.UserHomeDir()
		dir = filepath.Join(homeDir, dir[1:])
	}

	absPath, err := filepath.Abs(dir)
	if err != nil {
		return err
	}

	if gt.seenPaths[absPath] {
		return nil
	}
	gt.seenPaths[absPath] = true

	entries, err := os.ReadDir(dir)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		skipDirs := map[string]bool{
			"node_modules": true,
			".npm":         true,
			".cache":       true,
			"vendor":       true,
			"venv":         true,
			".venv":        true,
			"dist":         true,
			"build":        true,
			"Library":      true,
			"Applications": true,
		}

		if skipDirs[entry.Name()] {
			continue
		}

		fullPath := filepath.Join(dir, entry.Name())

		gitPath := filepath.Join(fullPath, ".git")
		if _, err := os.Stat(gitPath); err == nil {

			repo, err := gt.extractRepoInfo(fullPath)
			if err == nil {
				gt.repos = append(gt.repos, repo)
			}

			continue
		}

		gt.scanDir(fullPath, depth+1, maxDepth)
	}

	return nil
}

func (gt *GitTracker) extractRepoInfo(repoPath string) (GitRepo, error) {
	repo := GitRepo{
		Path:    repoPath,
		Remotes: []string{},
	}

	cmd := exec.Command("git", "-C", repoPath, "remote", "get-url", "origin")
	output, err := cmd.Output()
	if err == nil {
		repo.RemoteURL = strings.TrimSpace(string(output))
	}

	cmd = exec.Command("git", "-C", repoPath, "remote", "-v")
	output, err = cmd.Output()
	if err == nil {
		lines := strings.Split(string(output), "\n")
		seen := make(map[string]bool)
		for _, line := range lines {
			if line == "" {
				continue
			}
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				remote := parts[0] + " " + parts[1]
				if !seen[remote] {
					repo.Remotes = append(repo.Remotes, remote)
					seen[remote] = true
				}
			}
		}
	}

	cmd = exec.Command("git", "-C", repoPath, "rev-parse", "--abbrev-ref", "HEAD")
	output, err = cmd.Output()
	if err == nil {
		repo.Branch = strings.TrimSpace(string(output))
	}

	cmd = exec.Command("git", "-C", repoPath, "status", "--porcelain")
	output, err = cmd.Output()
	if err == nil {
		repo.Dirty = len(strings.TrimSpace(string(output))) > 0
	}

	return repo, nil
}

func (gt *GitTracker) Save() error {
	if len(gt.repos) == 0 {
		return fmt.Errorf("no repositories found")
	}

	if err := os.MkdirAll(gt.outputDir, 0755); err != nil {
		return err
	}

	jsonFile := filepath.Join(gt.outputDir, "git-repos.json")
	data, err := json.MarshalIndent(gt.repos, "", "  ")
	if err != nil {
		return err
	}

	if err := os.WriteFile(jsonFile, data, 0644); err != nil {
		return err
	}

	textFile := filepath.Join(gt.outputDir, "git-repos.txt")
	var text strings.Builder
	text.WriteString("# Git Repositories\n")
	text.WriteString("# This is a list of git repositories found on your system\n")
	text.WriteString("# Use this to re-clone repos on a new machine\n\n")

	for _, repo := range gt.repos {
		text.WriteString(fmt.Sprintf("# Path: %s\n", repo.Path))
		text.WriteString(fmt.Sprintf("# Branch: %s", repo.Branch))
		if repo.Dirty {
			text.WriteString(" (uncommitted changes)")
		}
		text.WriteString("\n")
		if repo.RemoteURL != "" {
			text.WriteString(fmt.Sprintf("git clone %s\n", repo.RemoteURL))
		} else {
			text.WriteString("# No remote URL found\n")
		}
		text.WriteString("\n")
	}

	if err := os.WriteFile(textFile, []byte(text.String()), 0644); err != nil {
		return err
	}

	scriptFile := filepath.Join(gt.outputDir, "clone-repos.sh")
	var script strings.Builder
	script.WriteString("#!/bin/bash\n")
	script.WriteString("# Git Repository Clone Script\n")
	script.WriteString("# Generated by stash\n\n")
	script.WriteString("set -e\n\n")
	script.WriteString("echo \"üìÅ Cloning repositories...\"\n\n")

	for _, repo := range gt.repos {
		if repo.RemoteURL != "" {

			repoName := filepath.Base(repo.Path)
			script.WriteString(fmt.Sprintf("# Original path: %s\n", repo.Path))
			script.WriteString(fmt.Sprintf("if [ ! -d \"%s\" ]; then\n", repoName))
			script.WriteString(fmt.Sprintf("  echo \"Cloning %s...\"\n", repoName))
			script.WriteString(fmt.Sprintf("  git clone %s\n", repo.RemoteURL))
			if repo.Branch != "main" && repo.Branch != "master" {
				script.WriteString(fmt.Sprintf("  cd %s && git checkout %s && cd ..\n", repoName, repo.Branch))
			}
			script.WriteString("else\n")
			script.WriteString(fmt.Sprintf("  echo \"Skipping %s (already exists)\"\n", repoName))
			script.WriteString("fi\n\n")
		}
	}

	script.WriteString("echo \"‚úì Done!\"\n")

	return os.WriteFile(scriptFile, []byte(script.String()), 0755)
}

func (gt *GitTracker) GetCount() int {
	return len(gt.repos)
}

func (gt *GitTracker) GetRepos() []GitRepo {
	return gt.repos
}
